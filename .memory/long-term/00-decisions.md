# 주요 결정사항

## 아키텍처 결정

### 2계층 구조 (2025-01-08)
- **결정**: Domain ↔ Infrastructure (Application 레이어 제거)
- **이유**: 중간 전달 레이어가 불필요, 복잡도 45% 감소
- **효과**: 직접 호출로 코드 추적 용이

### Hexagonal Architecture → 단순화
- **초기**: Ports & Adapters 패턴 채택
- **문제**: 과도한 추상화, God Object (Model 115+ 필드)
- **해결**: 2계층으로 단순화하되 인터페이스 분리 유지

### Factory 패턴 (2025-01-08)
- **변경**: Registry 패턴 → 단순 Factory 함수
- **이유**: Provider 1개만 관리하는데 복잡한 Registry 불필요
- **구현**: switch 문으로 직접 생성

## 기술 선택

### CLI-First 접근 (2025-01-07)
- **변경**: TUI 중심 → CLI 우선 개발
- **이유**: 테스트 용이, 즉각적 가치 제공, 자동화 가능
- **원칙**: "Make it work → Make it right → Make it pretty"

### TUI 라이브러리 (2025-01-08)
- **변경**: Bubble Tea → tview
- **이유**: 즉시 사용 가능한 위젯, 단순한 구조
- **구현**: CLI 래퍼 방식 (~800줄)

### 백업 무결성 (2025-01-08)
- **방법**: 임시파일 + 원자적 rename
- **체크섬**: SHA256 스트리밍 계산
- **복잡도**: 25/100 (3-4줄로 해결)

## 개발 원칙

### Occam's Razor
- **기준**: 복잡도 70 이상 거부
- **적용**: Registry 제거, Application 레이어 제거
- **결과**: 코드 35% 감소, 파일 40% 감소

### TDD & Tidy First
- **순서**: Red → Green → Refactor
- **분리**: 구조적 변경과 행동적 변경 분리
- **커밋**: 한 번에 하나의 논리적 변경만

### 진행률 보고 (2025-07-08)
- **3초 규칙**: 3초 이상 작업은 진행률 필수
- **다중 환경**: Terminal, CI/CD, 로그, TUI 통합
- **구현**: io.TeeReader로 표준 라이브러리만 사용

## 전략적 결정

### Provider 확장 전략
- **현재**: Filesystem provider만 완전 구현
- **미래**: MinIO, MongoDB는 Phase 5로 연기
- **이유**: 실사용 피드백 후 필요시 추가

### 메타데이터 관리
- **저장**: 로컬 파일 시스템 (JSON)
- **위치**: ~/.cli-recover/metadata/
- **이유**: 단순함, 외부 의존성 없음

### 도구 의존성 (계획)
- **문제**: kubectl 없으면 실패
- **해결**: 자동 다운로드 (Phase 3.12)
- **복잡도**: 50/100 예상

## CLI 디자인 결정 (2025-01-09)

### 플래그 관리 전략
- **문제**: 플래그 단축키 충돌 (-o, -c, -t)
- **해결**: 중앙 레지스트리 + 컴파일 타임 검증
- **원칙**: POSIX/GNU 표준 준수, kubectl/docker 패턴 참고

### 명령어 패턴
- **스타일**: 하이브리드 (positional args + flags)
- **예시**: `backup filesystem <pod> <path> [options]`
- **이유**: 직관적이면서 유연함

### 에러 처리 철학
- **구조**: What (무엇이) → Why (왜) → How (어떻게)
- **목표**: 사용자가 스스로 해결 가능하도록
- **구현**: 도메인별 에러 타입 + 사용자 친화적 변환
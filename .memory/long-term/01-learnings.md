# 프로젝트 학습 사항

## Bubble Tea 프레임워크 (역사적 기록)
**기간**: 2024-12 ~ 2025-01
**결과**: TUI 완전 삭제 결정
**교훈**: 
- God Object 안티패턴 회피 (Model 115+ 필드)
- 비즈니스 로직과 UI 분리 필수
- 테스트 가능한 구조 중요
- CLI-first 접근이 더 실용적

## 아키텍처 교훈

### God Object 안티패턴
**문제**: 한 객체가 너무 많은 책임을 가짐
**예시**: TUI Model 115+ 필드
**해결**:
- 도메인별 분리
- 인터페이스 기반 설계
- 컴포지션 활용

### 메모리 누수 이슈
**문제**: 무제한 출력 버퍼로 OOM 발생
**원인**: []string으로 모든 출력 저장
**해결**: Ring Buffer 도입
**교훈**: 리소스 제한 항상 고려

### 테스트 가능한 구조
**문제**: 외부 의존성 직접 사용
**해결**: Provider 패턴, 인터페이스 기반 설계
**효과**: 단위 테스트 가능, 통합 테스트 격리

### CLI vs TUI 복잡도
**발견**: CLI가 TUI보다 테스트하기 쉬움
**이유**: 입출력 명확, 상태 관리 단순
**결론**: 핵심 기능은 CLI로, TUI는 얇은 래퍼로

### 코드 중복 제거 (TDD)
**방법**: 호환성 테스트 → 검증 → 제거
**효과**: 안전한 레거시 제거
**교훈**: 테스트 없이 삭제 금지

### 로그 시스템 구현
**핵심 설계**:
- 인터페이스 기반 (domain/logger)
- 다중 출력 지원
- 구조화된 로깅
- 자동 로테이션
**모범 사례**:
- WithField/WithFields로 컨텍스트
- 레벨 체크로 성능 보호
- 테스트 용이한 설계

## 테스트 전략

### 테스트 커버리지
**변화**: 61.1% → 53.0%
**이유**: TUI 코드 제거로 전체 비율 변화
**실제**: 비즈니스 로직 커버리지 유지
**교훈**: UI 레이어는 테스트 제외 가능

### 테스트 가능한 구조
**Provider 패턴**: 인터페이스로 Mock 가능
**의존성 주입**: 테스트 시 주입 가능
**Golden File**: kubectl 출력 모킹

## 프로세스 관리

### 좀비 프로세스 방지
```go
defer func() {
    if cmd.Process != nil {
        cmd.Process.Kill()
    }
}()
```
**교훈**: 리소스 정리 항상 defer

### Context 타임아웃
**필수**: 모든 외부 명령에 timeout
**방법**: context.WithTimeout
**효과**: 무한 대기 방지

## 헥사고날 아키텍처

### 레이어 분리
- **Domain**: 비즈니스 로직만
- **Infrastructure**: 외부 시스템 연동
- **Application**: 조율 및 서비스
- **Presentation**: UI (CLI/TUI)

### 의존성 방향
- 안쪽으로만 의존
- 인터페이스로 역전
- 외부 변경에 강건

### 실무 적용
**성공**: Provider 패턴으로 확장성
**실패**: TUI에 비즈니스 로직 혼재
**교훈**: 아키텍처 원칙 엄격히 준수

## Phase 3 교훈 (2025-01-07)

### Occam's Razor 원칙
**문제**: 백그라운드 실행 과도하게 복잡 (복잡도 80)
**해결**: 단순한 로그 시스템으로 대체 (복잡도 30)
**교훈**:
- 복잡한 기능이 항상 좋은 것은 아님
- 실제 필요성 검증 후 구현
- 단순함이 유지보수에 유리

### 기존 시스템 활용
**발견**: logger (디버깅용)와 log (이력용) 구분
**효과**: 각자 목적에 맞게 사용
**교훈**: 새로 만들기 전에 기존 것 확인

### 롤백의 중요성
**상황**: 과도한 구현 후 방향 전환
**방법**: git reset --hard로 깨끗하게
**교훈**: 잘못된 길은 빠르게 포기

## Phase 4 교훈 (2025-01-07)

### TUI 라이브러리 선택
**비교**: Bubble Tea vs tview
**선택**: tview
**이유**:
- 즉시 사용 가능한 위젯
- 단순한 구조로 복잡도 관리 용이
- K9s 등 성공 사례 존재

### CLI 래퍼 방식
**접근**: TUI는 CLI 명령어 실행하는 얇은 래퍼
**장점**:
- 비즈니스 로직 중복 없음
- 테스트된 CLI 기능 재사용
- 복잡도 관리 용이 (40/100)

### 구현 단순화
**파일 수**: 7개 파일, 총 800줄
**핵심**: 
- God Object 회피
- 상태 관리 최소화
- tview 기본 위젯만 사용
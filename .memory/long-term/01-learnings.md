# 프로젝트 학습 사항

## Bubble Tea 프레임워크 (역사적 기록)
**기간**: 2024-12 ~ 2025-01
**결과**: TUI 완전 삭제 결정
**교훈**: 
- God Object 안티패턴 회피 (Model 115+ 필드)
- 비즈니스 로직과 UI 분리 필수
- 테스트 가능한 구조 중요
- CLI-first 접근이 더 실용적

## 아키텍처 교훈

### God Object 안티패턴
**문제**: 한 객체가 너무 많은 책임을 가짐
**예시**: TUI Model 115+ 필드
**해결**:
- 도메인별 분리
- 인터페이스 기반 설계
- 컴포지션 활용

### 메모리 누수 이슈
**문제**: 무제한 출력 버퍼로 OOM 발생
**원인**: []string으로 모든 출력 저장
**해결**: Ring Buffer 도입
**교훈**: 리소스 제한 항상 고려

### 테스트 가능한 구조
**문제**: 외부 의존성 직접 사용
**해결**: Provider 패턴, 인터페이스 기반 설계
**효과**: 단위 테스트 가능, 통합 테스트 격리

### CLI vs TUI 복잡도
**발견**: CLI가 TUI보다 테스트하기 쉬움
**이유**: 입출력 명확, 상태 관리 단순
**결론**: 핵심 기능은 CLI로, TUI는 얇은 래퍼로

### 코드 중복 제거 (TDD)
**방법**: 호환성 테스트 → 검증 → 제거
**효과**: 안전한 레거시 제거
**교훈**: 테스트 없이 삭제 금지

### 로그 시스템 구현
**핵심 설계**:
- 인터페이스 기반 (domain/logger)
- 다중 출력 지원
- 구조화된 로깅
- 자동 로테이션
**모범 사례**:
- WithField/WithFields로 컨텍스트
- 레벨 체크로 성능 보호
- 테스트 용이한 설계

## 테스트 전략

### 테스트 커버리지
**변화**: 61.1% → 53.0%
**이유**: TUI 코드 제거로 전체 비율 변화
**실제**: 비즈니스 로직 커버리지 유지
**교훈**: UI 레이어는 테스트 제외 가능

### 테스트 가능한 구조
**Provider 패턴**: 인터페이스로 Mock 가능
**의존성 주입**: 테스트 시 주입 가능
**Golden File**: kubectl 출력 모킹

## 프로세스 관리

### 좀비 프로세스 방지
```go
defer func() {
    if cmd.Process != nil {
        cmd.Process.Kill()
    }
}()
```
**교훈**: 리소스 정리 항상 defer

### Context 타임아웃
**필수**: 모든 외부 명령에 timeout
**방법**: context.WithTimeout
**효과**: 무한 대기 방지

## 헥사고날 아키텍처

### 레이어 분리
- **Domain**: 비즈니스 로직만
- **Infrastructure**: 외부 시스템 연동
- **Application**: 조율 및 서비스
- **Presentation**: UI (CLI/TUI)

### 의존성 방향
- 안쪽으로만 의존
- 인터페이스로 역전
- 외부 변경에 강건

### 실무 적용
**성공**: Provider 패턴으로 확장성
**실패**: TUI에 비즈니스 로직 혼재
**교훈**: 아키텍처 원칙 엄격히 준수

## Phase 3 교훈 (2025-01-07)

### Occam's Razor 원칙
**문제**: 백그라운드 실행 과도하게 복잡 (복잡도 80)
**해결**: 단순한 로그 시스템으로 대체 (복잡도 30)
**교훈**:
- 복잡한 기능이 항상 좋은 것은 아님
- 실제 필요성 검증 후 구현
- 단순함이 유지보수에 유리

### 기존 시스템 활용
**발견**: logger (디버깅용)와 log (이력용) 구분
**효과**: 각자 목적에 맞게 사용
**교훈**: 새로 만들기 전에 기존 것 확인

### 롤백의 중요성
**상황**: 과도한 구현 후 방향 전환
**방법**: git reset --hard로 깨끗하게
**교훈**: 잘못된 길은 빠르게 포기

## Phase 4 교훈 (2025-01-07)

### TUI 라이브러리 선택
**비교**: Bubble Tea vs tview
**선택**: tview
**이유**:
- 즉시 사용 가능한 위젯
- 단순한 구조로 복잡도 관리 용이
- K9s 등 성공 사례 존재

### CLI 래퍼 방식
**접근**: TUI는 CLI 명령어 실행하는 얇은 래퍼
**장점**:
- 비즈니스 로직 중복 없음
- 테스트된 CLI 기능 재사용
- 복잡도 관리 용이 (40/100)

### 구현 단순화
**파일 수**: 7개 파일, 총 800줄
**핵심**: 
- God Object 회피
- 상태 관리 최소화
- tview 기본 위젯만 사용

## Phase 3.10 교훈: 파일 무결성 (2025-01-08)

### 파일 손상 위험 분석
**발견**: 백업 중단 시 불완전한 파일 생성
**위험도**: 95/100 (치명적)
**시나리오**:
- 10GB 백업 중 7GB에서 중단
- 손상된 tar 파일이 그대로 남음
- 사용자가 완전한지 알 수 없음

### 원자적 파일 연산의 중요성
**해결책**: 임시 파일 + os.Rename
**이유**:
- OS 레벨 원자성 보장
- 중간 상태 없음 (all or nothing)
- 같은 파일시스템 내에서 O(1) 성능

### Occam's Razor 적용
**복잡한 대안들**:
- 파일 잠금 (복잡도 50)
- 체크섬 스트리밍 (복잡도 60)
- 트랜잭션 로그 (복잡도 80)

**선택한 해결책** (복잡도 25):
```go
tempFile := outputFile + ".tmp"
defer func() {
    if !success {
        os.Remove(tempFile)
    }
}()
// 쓰기 완료 후
os.Rename(tempFile, outputFile)
```

### 교훈
- 단순한 해결책이 가장 효과적
- OS 기본 기능 활용이 최선
- 3-4줄 코드로 큰 문제 해결 가능
- 외부 라이브러리 없이도 안전성 확보

## Phase 3.12 계획: 도구 자동 다운로드 (2025-01-08)

### 문제 인식
**발견**: kubectl, mc 등 외부 도구 의존성
**위험**: 도구가 없으면 백업/복원 실패
**사용자 경험**: 수동 설치 필요로 불편

### 설계 고민
**첫 충동**: 바로 구현 시작
**반성**: CLAUDE.md의 계획 우선 원칙 위반
**교정**: 구현 삭제하고 계획 문서화

### 복잡도 관리
**간단한 접근** (복잡도 30):
- PATH 확인 → 없으면 에러
- 설치 가이드 문서 제공

**선택한 접근** (복잡도 50):
- PATH 확인
- 로컬 캐시 확인
- 자동 다운로드
- 원자적 파일 저장

**과도한 접근** (복잡도 80+):
- 버전 관리 시스템
- 업데이트 체크
- 디지털 서명 검증

### 핵심 설계 결정
1. **도구별 격리**: kubectl과 mc 별도 메서드
2. **캐싱 전략**: ~/.cli-recover/tools/
3. **원자적 다운로드**: 임시파일 + rename
4. **플랫폼 감지**: runtime.GOOS/GOARCH

### 예상 교훈
- 사용자 경험과 복잡도의 균형
- 외부 의존성 관리의 중요성
- 네트워크 실패 처리 필수
- 보안(HTTPS)과 편의성 양립
# 프로젝트 학습 사항

## Bubble Tea 프레임워크 (역사적 기록)
**기간**: 2024-12 ~ 2025-01
**결과**: TUI 완전 삭제 결정
**교훈**: 
- God Object 안티패턴 회피 (Model 115+ 필드)
- 비즈니스 로직과 UI 분리 필수
- 테스트 가능한 구조 중요
- CLI-first 접근이 더 실용적

## 아키텍처 교훈

### God Object 안티패턴
**문제**: 한 객체가 너무 많은 책임을 가짐
**예시**: TUI Model 115+ 필드
**해결**:
- 도메인별 분리
- 인터페이스 기반 설계
- 컴포지션 활용

### 메모리 누수 이슈
**문제**: 무제한 출력 버퍼로 OOM 발생
**원인**: []string으로 모든 출력 저장
**해결**: Ring Buffer 도입
**교훈**: 리소스 제한 항상 고려

### 테스트 가능한 구조
**문제**: 외부 의존성 직접 사용
**해결**: Provider 패턴, 인터페이스 기반 설계
**효과**: 단위 테스트 가능, 통합 테스트 격리

### CLI vs TUI 복잡도
**발견**: CLI가 TUI보다 테스트하기 쉬움
**이유**: 입출력 명확, 상태 관리 단순
**결론**: 핵심 기능은 CLI로, TUI는 얇은 래퍼로

### 코드 중복 제거 (TDD)
**방법**: 호환성 테스트 → 검증 → 제거
**효과**: 안전한 레거시 제거
**교훈**: 테스트 없이 삭제 금지

### 로그 시스템 구현
**핵심 설계**:
- 인터페이스 기반 (domain/logger)
- 다중 출력 지원
- 구조화된 로깅
- 자동 로테이션
**모범 사례**:
- WithField/WithFields로 컨텍스트
- 레벨 체크로 성능 보호
- 테스트 용이한 설계

## 테스트 전략

### 테스트 커버리지
**변화**: 61.1% → 53.0%
**이유**: TUI 코드 제거로 전체 비율 변화
**실제**: 비즈니스 로직 커버리지 유지
**교훈**: UI 레이어는 테스트 제외 가능

### 테스트 가능한 구조
**Provider 패턴**: 인터페이스로 Mock 가능
**의존성 주입**: 테스트 시 주입 가능
**Golden File**: kubectl 출력 모킹

## 프로세스 관리

### 좀비 프로세스 방지
```go
defer func() {
    if cmd.Process != nil {
        cmd.Process.Kill()
    }
}()
```
**교훈**: 리소스 정리 항상 defer

### Context 타임아웃
**필수**: 모든 외부 명령에 timeout
**방법**: context.WithTimeout
**효과**: 무한 대기 방지

## 헥사고날 아키텍처

### 레이어 분리
- **Domain**: 비즈니스 로직만
- **Infrastructure**: 외부 시스템 연동
- **Application**: 조율 및 서비스
- **Presentation**: UI (CLI/TUI)

### 의존성 방향
- 안쪽으로만 의존
- 인터페이스로 역전
- 외부 변경에 강건

### 실무 적용
**성공**: Provider 패턴으로 확장성
**실패**: TUI에 비즈니스 로직 혼재
**교훈**: 아키텍처 원칙 엄격히 준수
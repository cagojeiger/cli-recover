# 백업 무결성 개요

## 목적
백업 프로세스에서 데이터 손실과 파일 손상을 방지하고, 생성된 백업 파일의 무결성을 보장하는 메커니즘을 구현합니다.

## 백업 무결성의 정의

백업 무결성은 세 가지 핵심 요소로 구성됩니다:

### 1. **파일 손상 방지 (Corruption Prevention)**
- 백업 프로세스 중단 시 불완전한 파일이 생성되지 않도록 보장
- 원자적(Atomic) 파일 연산을 통해 "모두 성공하거나 모두 실패" 원칙 적용

### 2. **데이터 무결성 (Data Integrity)**
- 백업 파일의 내용이 생성 시점과 동일하게 유지됨을 보장
- 체크섬(Checksum)을 통해 데이터 변경 감지

### 3. **백업 완전성 (Backup Completeness)**
- 의도한 모든 파일이 백업에 포함되었는지 검증
- 파일 수, 크기 등의 메타데이터 추적

## 파일 손상 시나리오

### 시나리오 1: 프로세스 중단
```
kubectl exec → tar 생성 → [50% 전송] → ^C (Ctrl+C)
                                        ↓
                                   backup.tar (손상됨)
```
**문제**: 불완전한 tar 파일이 존재하지만 사용자는 완전한지 알 수 없음

### 시나리오 2: 네트워크 오류
```
Pod → kubectl → [네트워크 끊김] → 일부 데이터만 저장
                                   ↓
                              backup.tar (불완전)
```
**문제**: tar 헤더는 정상이지만 데이터가 누락됨

### 시나리오 3: 디스크 공간 부족
```
10GB 백업 → 8GB 쓰기 → "no space left on device"
                         ↓
                    backup.tar (8GB만 존재)
```
**문제**: 부분적으로 생성된 파일을 정상 백업으로 착각 가능

## 해결 방안

### 1. 원자적 파일 쓰기
```go
// 위험한 방식
outputFile := "backup.tar"
writeData(outputFile)  // 중간에 실패하면?

// 안전한 방식
tempFile := "backup.tar.tmp"
writeData(tempFile)
os.Rename(tempFile, "backup.tar")  // 원자적 연산
```

### 2. 체크섬 검증
```go
// 스트리밍 중 체크섬 계산
type ChecksumWriter struct {
    writer io.Writer
    hash   hash.Hash
}

// 백업과 동시에 SHA256 계산
// 메모리 사용량: 파일 크기와 무관하게 ~64KB
```

### 3. 메타데이터 추적
```json
{
    "checksum": "a7b9c3d2e1f4...",
    "fileCount": 1523,
    "totalSize": 10737418240,
    "createdAt": "2025-01-08T10:00:00Z"
}
```

## 원자적 파일 연산의 원리

### 원자성(Atomicity)의 정의
- 연산이 완전히 성공하거나 완전히 실패함
- 중간 상태가 존재하지 않음
- 다른 프로세스가 불완전한 상태를 관찰할 수 없음

### OS 레벨 지원
```bash
# Linux/Unix: rename(2) 시스템 콜
# - 같은 파일시스템 내에서 원자적
# - inode 테이블의 메타데이터만 변경
# - O(1) 성능

# Windows: MoveFileEx with MOVEFILE_REPLACE_EXISTING
# - 원자적 교체 보장
```

## 체크섬의 역할과 한계

### 체크섬이 보장하는 것
1. **비트 단위 정확성**: 1비트라도 변경되면 감지
2. **전송 오류 감지**: 네트워크, 디스크 오류 검출
3. **우발적 변경 방지**: 의도하지 않은 수정 감지

### 체크섬이 보장하지 못하는 것
1. **원본 데이터 완전성**: tar가 모든 파일을 포함했는지
2. **백업 중 원본 변경**: 일관성 있는 스냅샷인지
3. **의도적 조작**: 악의적인 변경 (암호화 필요)

## 성능 고려사항

### 오버헤드 분석
```
작업                     | CPU | 메모리 | I/O  | 시간
------------------------|-----|--------|------|------
일반 백업               | 10% | 100MB  | 100% | 1.0x
+ 임시파일/Rename       | 10% | 100MB  | 100% | 1.0x
+ 체크섬 계산           | 15% | 100MB  | 100% | 1.05x
+ 메타데이터            | 15% | 101MB  | 100% | 1.05x
```

### 트레이드오프
- **안전성 vs 성능**: 5% 성능 저하로 100% 무결성 보장
- **복잡도 vs 신뢰성**: 단순한 구현으로 높은 신뢰성 달성

## 복잡도 평가 (Occam's Razor 적용)

### 선택한 해결책: 25/100 ✅
- 임시 파일 + 원자적 이동
- OS 기본 기능만 사용
- 외부 의존성 없음
- 3-4줄의 코드 추가

### 대안 비교
| 방법 | 복잡도 | 효과 | 권장 |
|------|--------|------|------|
| 파일 잠금 | 50 | 중간 | ❌ |
| WAL (Write-Ahead Log) | 65 | 높음 | ❌ |
| 분산 트랜잭션 | 80 | 매우높음 | ❌ |

## 결론

백업 무결성은 단순하면서도 효과적인 방법으로 달성할 수 있습니다:

1. **임시 파일 + 원자적 이동**으로 파일 손상 방지
2. **스트리밍 체크섬**으로 데이터 무결성 보장
3. **메타데이터 추적**으로 백업 완전성 검증

이 접근법은 Occam's Razor 원칙에 따라 최소한의 복잡도로 최대한의 안전성을 제공합니다.